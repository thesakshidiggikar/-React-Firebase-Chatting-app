{"ast":null,"code":"import _classCallCheck from \"E:\\\\Attempt9\\\\superchat\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"E:\\\\Attempt9\\\\superchat\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _asyncToGenerator from \"E:\\\\Attempt9\\\\superchat\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nimport firebase from '@firebase/app-compat';\nimport * as exp from '@firebase/auth/internal';\nimport { Component } from '@firebase/component';\nimport { isBrowserExtension, getUA, isReactNative, isNode, isIndexedDBAvailable, isIE, FirebaseError } from '@firebase/util';\nvar name = \"@firebase/auth-compat\";\nvar version = \"0.3.7\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1000;\nfunction _getCurrentScheme() {\n  var _a;\n  return ((_a = self === null || self === void 0 ? void 0 : self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;\n}\n/**\r\n * @return {boolean} Whether the current environment is http or https.\r\n */\nfunction _isHttpOrHttps() {\n  return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';\n}\n/**\r\n * @param {?string=} ua The user agent.\r\n * @return {boolean} Whether the app is rendered in a mobile iOS or Android\r\n *     Cordova environment.\r\n */\nfunction _isAndroidOrIosCordovaScheme() {\n  var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getUA();\n  return !!((_getCurrentScheme() === 'file:' || _getCurrentScheme() === 'ionic:' || _getCurrentScheme() === 'capacitor:') && ua.toLowerCase().match(/iphone|ipad|ipod|android/));\n}\n/**\r\n * @return {boolean} Whether the environment is a native environment, where\r\n *     CORS checks do not apply.\r\n */\nfunction _isNativeEnvironment() {\n  return isReactNative() || isNode();\n}\n/**\r\n * Checks whether the user agent is IE11.\r\n * @return {boolean} True if it is IE11.\r\n */\nfunction _isIe11() {\n  return isIE() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;\n}\n/**\r\n * Checks whether the user agent is Edge.\r\n * @param {string} userAgent The browser user agent string.\r\n * @return {boolean} True if it is Edge.\r\n */\nfunction _isEdge() {\n  var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getUA();\n  return /Edge\\/\\d+/.test(ua);\n}\n/**\r\n * @param {?string=} opt_userAgent The navigator user agent.\r\n * @return {boolean} Whether local storage is not synchronized between an iframe\r\n *     and a popup of the same domain.\r\n */\nfunction _isLocalStorageNotSynchronized() {\n  var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getUA();\n  return _isIe11() || _isEdge(ua);\n}\n/** @return {boolean} Whether web storage is supported. */\nfunction _isWebStorageSupported() {\n  try {\n    var storage = self.localStorage;\n    var key = exp._generateEventId();\n    if (storage) {\n      // setItem will throw an exception if we cannot access WebStorage (e.g.,\n      // Safari in private mode).\n      storage['setItem'](key, '1');\n      storage['removeItem'](key);\n      // For browsers where iframe web storage does not synchronize with a popup\n      // of the same domain, indexedDB is used for persistent storage. These\n      // browsers include IE11 and Edge.\n      // Make sure it is supported (IE11 and Edge private mode does not support\n      // that).\n      if (_isLocalStorageNotSynchronized()) {\n        // In such browsers, if indexedDB is not supported, an iframe cannot be\n        // notified of the popup sign in result.\n        return isIndexedDBAvailable();\n      }\n      return true;\n    }\n  } catch (e) {\n    // localStorage is not available from a worker. Test availability of\n    // indexedDB.\n    return _isWorker() && isIndexedDBAvailable();\n  }\n  return false;\n}\n/**\r\n * @param {?Object=} global The optional global scope.\r\n * @return {boolean} Whether current environment is a worker.\r\n */\nfunction _isWorker() {\n  // WorkerGlobalScope only defined in worker environment.\n  return typeof global !== 'undefined' && 'WorkerGlobalScope' in global && 'importScripts' in global;\n}\nfunction _isPopupRedirectSupported() {\n  return (_isHttpOrHttps() || isBrowserExtension() || _isAndroidOrIosCordovaScheme()) &&\n  // React Native with remote debugging reports its location.protocol as\n  // http.\n  !_isNativeEnvironment() &&\n  // Local storage has to be supported for browser popup and redirect\n  // operations to work.\n  _isWebStorageSupported() &&\n  // DOM, popups and redirects are not supported within a worker.\n  !_isWorker();\n}\n/** Quick check that indicates the platform *may* be Cordova */\nfunction _isLikelyCordova() {\n  return _isAndroidOrIosCordovaScheme() && typeof document !== 'undefined';\n}\nfunction _isCordova() {\n  return _isCordova2.apply(this, arguments);\n}\nfunction _isCordova2() {\n  _isCordova2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n    return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n      while (1) switch (_context17.prev = _context17.next) {\n        case 0:\n          if (_isLikelyCordova()) {\n            _context17.next = 2;\n            break;\n          }\n          return _context17.abrupt(\"return\", false);\n        case 2:\n          return _context17.abrupt(\"return\", new Promise(function (resolve) {\n            var timeoutId = setTimeout(function () {\n              // We've waited long enough; the telltale Cordova event didn't happen\n              resolve(false);\n            }, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);\n            document.addEventListener('deviceready', function () {\n              clearTimeout(timeoutId);\n              resolve(true);\n            });\n          }));\n        case 3:\n        case \"end\":\n          return _context17.stop();\n      }\n    }, _callee17);\n  }));\n  return _isCordova2.apply(this, arguments);\n}\nfunction _getSelfWindow() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar Persistence = {\n  LOCAL: 'local',\n  NONE: 'none',\n  SESSION: 'session'\n};\nvar _assert$3 = exp._assert;\nvar PERSISTENCE_KEY = 'persistence';\n/**\r\n * Validates that an argument is a valid persistence value. If an invalid type\r\n * is specified, an error is thrown synchronously.\r\n */\nfunction _validatePersistenceArgument(auth, persistence) {\n  _assert$3(Object.values(Persistence).includes(persistence), auth, \"invalid-persistence-type\" /* exp.AuthErrorCode.INVALID_PERSISTENCE */);\n  // Validate if the specified type is supported in the current environment.\n  if (isReactNative()) {\n    // This is only supported in a browser.\n    _assert$3(persistence !== Persistence.SESSION, auth, \"unsupported-persistence-type\" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);\n    return;\n  }\n  if (isNode()) {\n    // Only none is supported in Node.js.\n    _assert$3(persistence === Persistence.NONE, auth, \"unsupported-persistence-type\" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);\n    return;\n  }\n  if (_isWorker()) {\n    // In a worker environment, either LOCAL or NONE are supported.\n    // If indexedDB not supported and LOCAL provided, throw an error\n    _assert$3(persistence === Persistence.NONE || persistence === Persistence.LOCAL && isIndexedDBAvailable(), auth, \"unsupported-persistence-type\" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);\n    return;\n  }\n  // This is restricted by what the browser supports.\n  _assert$3(persistence === Persistence.NONE || _isWebStorageSupported(), auth, \"unsupported-persistence-type\" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);\n}\nfunction _savePersistenceForRedirect(_x) {\n  return _savePersistenceForRedirect2.apply(this, arguments);\n}\nfunction _savePersistenceForRedirect2() {\n  _savePersistenceForRedirect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(auth) {\n    var session, key;\n    return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n      while (1) switch (_context18.prev = _context18.next) {\n        case 0:\n          _context18.next = 2;\n          return auth._initializationPromise;\n        case 2:\n          session = getSessionStorageIfAvailable();\n          key = exp._persistenceKeyName(PERSISTENCE_KEY, auth.config.apiKey, auth.name);\n          if (session) {\n            session.setItem(key, auth._getPersistence());\n          }\n        case 5:\n        case \"end\":\n          return _context18.stop();\n      }\n    }, _callee18);\n  }));\n  return _savePersistenceForRedirect2.apply(this, arguments);\n}\nfunction _getPersistencesFromRedirect(apiKey, appName) {\n  var session = getSessionStorageIfAvailable();\n  if (!session) {\n    return [];\n  }\n  var key = exp._persistenceKeyName(PERSISTENCE_KEY, apiKey, appName);\n  var persistence = session.getItem(key);\n  switch (persistence) {\n    case Persistence.NONE:\n      return [exp.inMemoryPersistence];\n    case Persistence.LOCAL:\n      return [exp.indexedDBLocalPersistence, exp.browserSessionPersistence];\n    case Persistence.SESSION:\n      return [exp.browserSessionPersistence];\n    default:\n      return [];\n  }\n}\n/** Returns session storage, or null if the property access errors */\nfunction getSessionStorageIfAvailable() {\n  var _a;\n  try {\n    return ((_a = _getSelfWindow()) === null || _a === void 0 ? void 0 : _a.sessionStorage) || null;\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar _assert$2 = exp._assert;\n/** Platform-agnostic popup-redirect resolver */\nvar CompatPopupRedirectResolver = /*#__PURE__*/function () {\n  function CompatPopupRedirectResolver() {\n    _classCallCheck(this, CompatPopupRedirectResolver);\n    // Create both resolvers for dynamic resolution later\n    this.browserResolver = exp._getInstance(exp.browserPopupRedirectResolver);\n    this.cordovaResolver = exp._getInstance(exp.cordovaPopupRedirectResolver);\n    // The actual resolver in use: either browserResolver or cordovaResolver.\n    this.underlyingResolver = null;\n    this._redirectPersistence = exp.browserSessionPersistence;\n    this._completeRedirectFn = exp._getRedirectResult;\n    this._overrideRedirectResult = exp._overrideRedirectResult;\n  }\n  _createClass(CompatPopupRedirectResolver, [{\n    key: \"_initialize\",\n    value: function () {\n      var _initialize2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(auth) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.selectUnderlyingResolver();\n            case 2:\n              return _context.abrupt(\"return\", this.assertedUnderlyingResolver._initialize(auth));\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function _initialize(_x2) {\n        return _initialize2.apply(this, arguments);\n      }\n      return _initialize;\n    }()\n  }, {\n    key: \"_openPopup\",\n    value: function () {\n      var _openPopup2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(auth, provider, authType, eventId) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.selectUnderlyingResolver();\n            case 2:\n              return _context2.abrupt(\"return\", this.assertedUnderlyingResolver._openPopup(auth, provider, authType, eventId));\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _openPopup(_x3, _x4, _x5, _x6) {\n        return _openPopup2.apply(this, arguments);\n      }\n      return _openPopup;\n    }()\n  }, {\n    key: \"_openRedirect\",\n    value: function () {\n      var _openRedirect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(auth, provider, authType, eventId) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.selectUnderlyingResolver();\n            case 2:\n              return _context3.abrupt(\"return\", this.assertedUnderlyingResolver._openRedirect(auth, provider, authType, eventId));\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function _openRedirect(_x7, _x8, _x9, _x10) {\n        return _openRedirect2.apply(this, arguments);\n      }\n      return _openRedirect;\n    }()\n  }, {\n    key: \"_isIframeWebStorageSupported\",\n    value: function _isIframeWebStorageSupported(auth, cb) {\n      this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth, cb);\n    }\n  }, {\n    key: \"_originValidation\",\n    value: function _originValidation(auth) {\n      return this.assertedUnderlyingResolver._originValidation(auth);\n    }\n  }, {\n    key: \"selectUnderlyingResolver\",\n    value: function () {\n      var _selectUnderlyingResolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var isCordova;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!this.underlyingResolver) {\n                _context4.next = 2;\n                break;\n              }\n              return _context4.abrupt(\"return\");\n            case 2:\n              _context4.next = 4;\n              return _isCordova();\n            case 4:\n              isCordova = _context4.sent;\n              this.underlyingResolver = isCordova ? this.cordovaResolver : this.browserResolver;\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function selectUnderlyingResolver() {\n        return _selectUnderlyingResolver.apply(this, arguments);\n      }\n      return selectUnderlyingResolver;\n    }()\n  }, {\n    key: \"_shouldInitProactively\",\n    get: function get() {\n      return _isLikelyCordova() || this.browserResolver._shouldInitProactively;\n    }\n  }, {\n    key: \"assertedUnderlyingResolver\",\n    get: function get() {\n      _assert$2(this.underlyingResolver, \"internal-error\" /* exp.AuthErrorCode.INTERNAL_ERROR */);\n      return this.underlyingResolver;\n    }\n  }]);\n  return CompatPopupRedirectResolver;\n}();\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction unwrap(object) {\n  return object.unwrap();\n}\nfunction wrapped(object) {\n  return object.wrapped();\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction credentialFromResponse(userCredential) {\n  return credentialFromObject(userCredential);\n}\nfunction attachExtraErrorFields(auth, e) {\n  var _a;\n  // The response contains all fields from the server which may or may not\n  // actually match the underlying type\n  var response = (_a = e.customData) === null || _a === void 0 ? void 0 : _a._tokenResponse;\n  if ((e === null || e === void 0 ? void 0 : e.code) === 'auth/multi-factor-auth-required') {\n    var mfaErr = e;\n    mfaErr.resolver = new MultiFactorResolver(auth, exp.getMultiFactorResolver(auth, e));\n  } else if (response) {\n    var credential = credentialFromObject(e);\n    var credErr = e;\n    if (credential) {\n      credErr.credential = credential;\n      credErr.tenantId = response.tenantId || undefined;\n      credErr.email = response.email || undefined;\n      credErr.phoneNumber = response.phoneNumber || undefined;\n    }\n  }\n}\nfunction credentialFromObject(object) {\n  var _ref = object instanceof FirebaseError ? object.customData : object,\n    _tokenResponse = _ref._tokenResponse;\n  if (!_tokenResponse) {\n    return null;\n  }\n  // Handle phone Auth credential responses, as they have a different format\n  // from other backend responses (i.e. no providerId). This is also only the\n  // case for user credentials (does not work for errors).\n  if (!(object instanceof FirebaseError)) {\n    if ('temporaryProof' in _tokenResponse && 'phoneNumber' in _tokenResponse) {\n      return exp.PhoneAuthProvider.credentialFromResult(object);\n    }\n  }\n  var providerId = _tokenResponse.providerId;\n  // Email and password is not supported as there is no situation where the\n  // server would return the password to the client.\n  if (!providerId || providerId === exp.ProviderId.PASSWORD) {\n    return null;\n  }\n  var provider;\n  switch (providerId) {\n    case exp.ProviderId.GOOGLE:\n      provider = exp.GoogleAuthProvider;\n      break;\n    case exp.ProviderId.FACEBOOK:\n      provider = exp.FacebookAuthProvider;\n      break;\n    case exp.ProviderId.GITHUB:\n      provider = exp.GithubAuthProvider;\n      break;\n    case exp.ProviderId.TWITTER:\n      provider = exp.TwitterAuthProvider;\n      break;\n    default:\n      var oauthIdToken = _tokenResponse.oauthIdToken,\n        oauthAccessToken = _tokenResponse.oauthAccessToken,\n        oauthTokenSecret = _tokenResponse.oauthTokenSecret,\n        pendingToken = _tokenResponse.pendingToken,\n        nonce = _tokenResponse.nonce;\n      if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {\n        return null;\n      }\n      // TODO(avolkovi): uncomment this and get it working with SAML & OIDC\n      if (pendingToken) {\n        if (providerId.startsWith('saml.')) {\n          return exp.SAMLAuthCredential._create(providerId, pendingToken);\n        } else {\n          // OIDC and non-default providers excluding Twitter.\n          return exp.OAuthCredential._fromParams({\n            providerId: providerId,\n            signInMethod: providerId,\n            pendingToken: pendingToken,\n            idToken: oauthIdToken,\n            accessToken: oauthAccessToken\n          });\n        }\n      }\n      return new exp.OAuthProvider(providerId).credential({\n        idToken: oauthIdToken,\n        accessToken: oauthAccessToken,\n        rawNonce: nonce\n      });\n  }\n  return object instanceof FirebaseError ? provider.credentialFromError(object) : provider.credentialFromResult(object);\n}\nfunction convertCredential(auth, credentialPromise) {\n  return credentialPromise.catch(function (e) {\n    if (e instanceof FirebaseError) {\n      attachExtraErrorFields(auth, e);\n    }\n    throw e;\n  }).then(function (credential) {\n    var operationType = credential.operationType;\n    var user = credential.user;\n    return {\n      operationType: operationType,\n      credential: credentialFromResponse(credential),\n      additionalUserInfo: exp.getAdditionalUserInfo(credential),\n      user: User.getOrCreate(user)\n    };\n  });\n}\nfunction convertConfirmationResult(_x11, _x12) {\n  return _convertConfirmationResult.apply(this, arguments);\n}\nfunction _convertConfirmationResult() {\n  _convertConfirmationResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(auth, confirmationResultPromise) {\n    var confirmationResultExp;\n    return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n      while (1) switch (_context19.prev = _context19.next) {\n        case 0:\n          _context19.next = 2;\n          return confirmationResultPromise;\n        case 2:\n          confirmationResultExp = _context19.sent;\n          return _context19.abrupt(\"return\", {\n            verificationId: confirmationResultExp.verificationId,\n            confirm: function confirm(verificationCode) {\n              return convertCredential(auth, confirmationResultExp.confirm(verificationCode));\n            }\n          });\n        case 4:\n        case \"end\":\n          return _context19.stop();\n      }\n    }, _callee19);\n  }));\n  return _convertConfirmationResult.apply(this, arguments);\n}\nvar MultiFactorResolver = /*#__PURE__*/function () {\n  function MultiFactorResolver(auth, resolver) {\n    _classCallCheck(this, MultiFactorResolver);\n    this.resolver = resolver;\n    this.auth = wrapped(auth);\n  }\n  _createClass(MultiFactorResolver, [{\n    key: \"resolveSignIn\",\n    value: function resolveSignIn(assertion) {\n      return convertCredential(unwrap(this.auth), this.resolver.resolveSignIn(assertion));\n    }\n  }, {\n    key: \"session\",\n    get: function get() {\n      return this.resolver.session;\n    }\n  }, {\n    key: \"hints\",\n    get: function get() {\n      return this.resolver.hints;\n    }\n  }]);\n  return MultiFactorResolver;\n}();\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar User = /*#__PURE__*/function () {\n  function User(_delegate) {\n    _classCallCheck(this, User);\n    this._delegate = _delegate;\n    this.multiFactor = exp.multiFactor(_delegate);\n  }\n  _createClass(User, [{\n    key: \"delete\",\n    value: function _delete() {\n      return this._delegate.delete();\n    }\n  }, {\n    key: \"reload\",\n    value: function reload() {\n      return this._delegate.reload();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._delegate.toJSON();\n    }\n  }, {\n    key: \"getIdTokenResult\",\n    value: function getIdTokenResult(forceRefresh) {\n      return this._delegate.getIdTokenResult(forceRefresh);\n    }\n  }, {\n    key: \"getIdToken\",\n    value: function getIdToken(forceRefresh) {\n      return this._delegate.getIdToken(forceRefresh);\n    }\n  }, {\n    key: \"linkAndRetrieveDataWithCredential\",\n    value: function linkAndRetrieveDataWithCredential(credential) {\n      return this.linkWithCredential(credential);\n    }\n  }, {\n    key: \"linkWithCredential\",\n    value: function () {\n      var _linkWithCredential = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(credential) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", convertCredential(this.auth, exp.linkWithCredential(this._delegate, credential)));\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function linkWithCredential(_x13) {\n        return _linkWithCredential.apply(this, arguments);\n      }\n      return linkWithCredential;\n    }()\n  }, {\n    key: \"linkWithPhoneNumber\",\n    value: function () {\n      var _linkWithPhoneNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(phoneNumber, applicationVerifier) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", convertConfirmationResult(this.auth, exp.linkWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier)));\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function linkWithPhoneNumber(_x14, _x15) {\n        return _linkWithPhoneNumber.apply(this, arguments);\n      }\n      return linkWithPhoneNumber;\n    }()\n  }, {\n    key: \"linkWithPopup\",\n    value: function () {\n      var _linkWithPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(provider) {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              return _context7.abrupt(\"return\", convertCredential(this.auth, exp.linkWithPopup(this._delegate, provider, CompatPopupRedirectResolver)));\n            case 1:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function linkWithPopup(_x16) {\n        return _linkWithPopup.apply(this, arguments);\n      }\n      return linkWithPopup;\n    }()\n  }, {\n    key: \"linkWithRedirect\",\n    value: function () {\n      var _linkWithRedirect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(provider) {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return _savePersistenceForRedirect(exp._castAuth(this.auth));\n            case 2:\n              return _context8.abrupt(\"return\", exp.linkWithRedirect(this._delegate, provider, CompatPopupRedirectResolver));\n            case 3:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function linkWithRedirect(_x17) {\n        return _linkWithRedirect.apply(this, arguments);\n      }\n      return linkWithRedirect;\n    }()\n  }, {\n    key: \"reauthenticateAndRetrieveDataWithCredential\",\n    value: function reauthenticateAndRetrieveDataWithCredential(credential) {\n      return this.reauthenticateWithCredential(credential);\n    }\n  }, {\n    key: \"reauthenticateWithCredential\",\n    value: function () {\n      var _reauthenticateWithCredential = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(credential) {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              return _context9.abrupt(\"return\", convertCredential(this.auth, exp.reauthenticateWithCredential(this._delegate, credential)));\n            case 1:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function reauthenticateWithCredential(_x18) {\n        return _reauthenticateWithCredential.apply(this, arguments);\n      }\n      return reauthenticateWithCredential;\n    }()\n  }, {\n    key: \"reauthenticateWithPhoneNumber\",\n    value: function reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) {\n      return convertConfirmationResult(this.auth, exp.reauthenticateWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));\n    }\n  }, {\n    key: \"reauthenticateWithPopup\",\n    value: function reauthenticateWithPopup(provider) {\n      return convertCredential(this.auth, exp.reauthenticateWithPopup(this._delegate, provider, CompatPopupRedirectResolver));\n    }\n  }, {\n    key: \"reauthenticateWithRedirect\",\n    value: function () {\n      var _reauthenticateWithRedirect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(provider) {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return _savePersistenceForRedirect(exp._castAuth(this.auth));\n            case 2:\n              return _context10.abrupt(\"return\", exp.reauthenticateWithRedirect(this._delegate, provider, CompatPopupRedirectResolver));\n            case 3:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function reauthenticateWithRedirect(_x19) {\n        return _reauthenticateWithRedirect.apply(this, arguments);\n      }\n      return reauthenticateWithRedirect;\n    }()\n  }, {\n    key: \"sendEmailVerification\",\n    value: function sendEmailVerification(actionCodeSettings) {\n      return exp.sendEmailVerification(this._delegate, actionCodeSettings);\n    }\n  }, {\n    key: \"unlink\",\n    value: function () {\n      var _unlink = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(providerId) {\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.next = 2;\n              return exp.unlink(this._delegate, providerId);\n            case 2:\n              return _context11.abrupt(\"return\", this);\n            case 3:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function unlink(_x20) {\n        return _unlink.apply(this, arguments);\n      }\n      return unlink;\n    }()\n  }, {\n    key: \"updateEmail\",\n    value: function updateEmail(newEmail) {\n      return exp.updateEmail(this._delegate, newEmail);\n    }\n  }, {\n    key: \"updatePassword\",\n    value: function updatePassword(newPassword) {\n      return exp.updatePassword(this._delegate, newPassword);\n    }\n  }, {\n    key: \"updatePhoneNumber\",\n    value: function updatePhoneNumber(phoneCredential) {\n      return exp.updatePhoneNumber(this._delegate, phoneCredential);\n    }\n  }, {\n    key: \"updateProfile\",\n    value: function updateProfile(profile) {\n      return exp.updateProfile(this._delegate, profile);\n    }\n  }, {\n    key: \"verifyBeforeUpdateEmail\",\n    value: function verifyBeforeUpdateEmail(newEmail, actionCodeSettings) {\n      return exp.verifyBeforeUpdateEmail(this._delegate, newEmail, actionCodeSettings);\n    }\n  }, {\n    key: \"emailVerified\",\n    get: function get() {\n      return this._delegate.emailVerified;\n    }\n  }, {\n    key: \"isAnonymous\",\n    get: function get() {\n      return this._delegate.isAnonymous;\n    }\n  }, {\n    key: \"metadata\",\n    get: function get() {\n      return this._delegate.metadata;\n    }\n  }, {\n    key: \"phoneNumber\",\n    get: function get() {\n      return this._delegate.phoneNumber;\n    }\n  }, {\n    key: \"providerData\",\n    get: function get() {\n      return this._delegate.providerData;\n    }\n  }, {\n    key: \"refreshToken\",\n    get: function get() {\n      return this._delegate.refreshToken;\n    }\n  }, {\n    key: \"tenantId\",\n    get: function get() {\n      return this._delegate.tenantId;\n    }\n  }, {\n    key: \"displayName\",\n    get: function get() {\n      return this._delegate.displayName;\n    }\n  }, {\n    key: \"email\",\n    get: function get() {\n      return this._delegate.email;\n    }\n  }, {\n    key: \"photoURL\",\n    get: function get() {\n      return this._delegate.photoURL;\n    }\n  }, {\n    key: \"providerId\",\n    get: function get() {\n      return this._delegate.providerId;\n    }\n  }, {\n    key: \"uid\",\n    get: function get() {\n      return this._delegate.uid;\n    }\n  }, {\n    key: \"auth\",\n    get: function get() {\n      return this._delegate.auth;\n    }\n  }], [{\n    key: \"getOrCreate\",\n    value: function getOrCreate(user) {\n      if (!User.USER_MAP.has(user)) {\n        User.USER_MAP.set(user, new User(user));\n      }\n      return User.USER_MAP.get(user);\n    }\n  }]);\n  return User;\n}(); // Maintain a map so that there's always a 1:1 mapping between new User and\n// legacy compat users\nUser.USER_MAP = new WeakMap();\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar _assert$1 = exp._assert;\nvar Auth = /*#__PURE__*/function () {\n  function Auth(app, provider) {\n    _classCallCheck(this, Auth);\n    this.app = app;\n    if (provider.isInitialized()) {\n      this._delegate = provider.getImmediate();\n      this.linkUnderlyingAuth();\n      return;\n    }\n    var apiKey = app.options.apiKey; // TODO: platform needs to be determined using heuristics\n    _assert$1(apiKey, \"invalid-api-key\" /* exp.AuthErrorCode.INVALID_API_KEY */, {\n      appName: app.name\n    });\n    // TODO: platform needs to be determined using heuristics\n    _assert$1(apiKey, \"invalid-api-key\" /* exp.AuthErrorCode.INVALID_API_KEY */, {\n      appName: app.name\n    });\n    // Only use a popup/redirect resolver in browser environments\n    var resolver = typeof window !== 'undefined' ? CompatPopupRedirectResolver : undefined;\n    this._delegate = provider.initialize({\n      options: {\n        persistence: buildPersistenceHierarchy(apiKey, app.name),\n        popupRedirectResolver: resolver\n      }\n    });\n    this._delegate._updateErrorMap(exp.debugErrorMap);\n    this.linkUnderlyingAuth();\n  }\n  _createClass(Auth, [{\n    key: \"useDeviceLanguage\",\n    value: function useDeviceLanguage() {\n      this._delegate.useDeviceLanguage();\n    }\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      return this._delegate.signOut();\n    }\n  }, {\n    key: \"useEmulator\",\n    value: function useEmulator(url, options) {\n      exp.connectAuthEmulator(this._delegate, url, options);\n    }\n  }, {\n    key: \"applyActionCode\",\n    value: function applyActionCode(code) {\n      return exp.applyActionCode(this._delegate, code);\n    }\n  }, {\n    key: \"checkActionCode\",\n    value: function checkActionCode(code) {\n      return exp.checkActionCode(this._delegate, code);\n    }\n  }, {\n    key: \"confirmPasswordReset\",\n    value: function confirmPasswordReset(code, newPassword) {\n      return exp.confirmPasswordReset(this._delegate, code, newPassword);\n    }\n  }, {\n    key: \"createUserWithEmailAndPassword\",\n    value: function () {\n      var _createUserWithEmailAndPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(email, password) {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              return _context12.abrupt(\"return\", convertCredential(this._delegate, exp.createUserWithEmailAndPassword(this._delegate, email, password)));\n            case 1:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function createUserWithEmailAndPassword(_x21, _x22) {\n        return _createUserWithEmailAndPassword.apply(this, arguments);\n      }\n      return createUserWithEmailAndPassword;\n    }()\n  }, {\n    key: \"fetchProvidersForEmail\",\n    value: function fetchProvidersForEmail(email) {\n      return this.fetchSignInMethodsForEmail(email);\n    }\n  }, {\n    key: \"fetchSignInMethodsForEmail\",\n    value: function fetchSignInMethodsForEmail(email) {\n      return exp.fetchSignInMethodsForEmail(this._delegate, email);\n    }\n  }, {\n    key: \"isSignInWithEmailLink\",\n    value: function isSignInWithEmailLink(emailLink) {\n      return exp.isSignInWithEmailLink(this._delegate, emailLink);\n    }\n  }, {\n    key: \"getRedirectResult\",\n    value: function () {\n      var _getRedirectResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var credential;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _assert$1(_isPopupRedirectSupported(), this._delegate, \"operation-not-supported-in-this-environment\" /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */);\n              _context13.next = 3;\n              return exp.getRedirectResult(this._delegate, CompatPopupRedirectResolver);\n            case 3:\n              credential = _context13.sent;\n              if (credential) {\n                _context13.next = 6;\n                break;\n              }\n              return _context13.abrupt(\"return\", {\n                credential: null,\n                user: null\n              });\n            case 6:\n              return _context13.abrupt(\"return\", convertCredential(this._delegate, Promise.resolve(credential)));\n            case 7:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function getRedirectResult() {\n        return _getRedirectResult.apply(this, arguments);\n      }\n      return getRedirectResult;\n    }() // This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.\n    // It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it\n    // out of autogenerated documentation pages to reduce accidental misuse.\n  }, {\n    key: \"addFrameworkForLogging\",\n    value: function addFrameworkForLogging(framework) {\n      exp.addFrameworkForLogging(this._delegate, framework);\n    }\n  }, {\n    key: \"onAuthStateChanged\",\n    value: function onAuthStateChanged(nextOrObserver, errorFn, completed) {\n      var _wrapObservers = wrapObservers(nextOrObserver, errorFn, completed),\n        next = _wrapObservers.next,\n        error = _wrapObservers.error,\n        complete = _wrapObservers.complete;\n      return this._delegate.onAuthStateChanged(next, error, complete);\n    }\n  }, {\n    key: \"onIdTokenChanged\",\n    value: function onIdTokenChanged(nextOrObserver, errorFn, completed) {\n      var _wrapObservers2 = wrapObservers(nextOrObserver, errorFn, completed),\n        next = _wrapObservers2.next,\n        error = _wrapObservers2.error,\n        complete = _wrapObservers2.complete;\n      return this._delegate.onIdTokenChanged(next, error, complete);\n    }\n  }, {\n    key: \"sendSignInLinkToEmail\",\n    value: function sendSignInLinkToEmail(email, actionCodeSettings) {\n      return exp.sendSignInLinkToEmail(this._delegate, email, actionCodeSettings);\n    }\n  }, {\n    key: \"sendPasswordResetEmail\",\n    value: function sendPasswordResetEmail(email, actionCodeSettings) {\n      return exp.sendPasswordResetEmail(this._delegate, email, actionCodeSettings || undefined);\n    }\n  }, {\n    key: \"setPersistence\",\n    value: function () {\n      var _setPersistence = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(persistence) {\n        var converted, isIndexedDBFullySupported;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _validatePersistenceArgument(this._delegate, persistence);\n              _context14.t0 = persistence;\n              _context14.next = _context14.t0 === Persistence.SESSION ? 4 : _context14.t0 === Persistence.LOCAL ? 6 : _context14.t0 === Persistence.NONE ? 11 : 13;\n              break;\n            case 4:\n              converted = exp.browserSessionPersistence;\n              return _context14.abrupt(\"break\", 14);\n            case 6:\n              _context14.next = 8;\n              return exp._getInstance(exp.indexedDBLocalPersistence)._isAvailable();\n            case 8:\n              isIndexedDBFullySupported = _context14.sent;\n              converted = isIndexedDBFullySupported ? exp.indexedDBLocalPersistence : exp.browserLocalPersistence;\n              return _context14.abrupt(\"break\", 14);\n            case 11:\n              converted = exp.inMemoryPersistence;\n              return _context14.abrupt(\"break\", 14);\n            case 13:\n              return _context14.abrupt(\"return\", exp._fail(\"argument-error\" /* exp.AuthErrorCode.ARGUMENT_ERROR */, {\n                appName: this._delegate.name\n              }));\n            case 14:\n              return _context14.abrupt(\"return\", this._delegate.setPersistence(converted));\n            case 15:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function setPersistence(_x23) {\n        return _setPersistence.apply(this, arguments);\n      }\n      return setPersistence;\n    }()\n  }, {\n    key: \"signInAndRetrieveDataWithCredential\",\n    value: function signInAndRetrieveDataWithCredential(credential) {\n      return this.signInWithCredential(credential);\n    }\n  }, {\n    key: \"signInAnonymously\",\n    value: function signInAnonymously() {\n      return convertCredential(this._delegate, exp.signInAnonymously(this._delegate));\n    }\n  }, {\n    key: \"signInWithCredential\",\n    value: function signInWithCredential(credential) {\n      return convertCredential(this._delegate, exp.signInWithCredential(this._delegate, credential));\n    }\n  }, {\n    key: \"signInWithCustomToken\",\n    value: function signInWithCustomToken(token) {\n      return convertCredential(this._delegate, exp.signInWithCustomToken(this._delegate, token));\n    }\n  }, {\n    key: \"signInWithEmailAndPassword\",\n    value: function signInWithEmailAndPassword(email, password) {\n      return convertCredential(this._delegate, exp.signInWithEmailAndPassword(this._delegate, email, password));\n    }\n  }, {\n    key: \"signInWithEmailLink\",\n    value: function signInWithEmailLink(email, emailLink) {\n      return convertCredential(this._delegate, exp.signInWithEmailLink(this._delegate, email, emailLink));\n    }\n  }, {\n    key: \"signInWithPhoneNumber\",\n    value: function signInWithPhoneNumber(phoneNumber, applicationVerifier) {\n      return convertConfirmationResult(this._delegate, exp.signInWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));\n    }\n  }, {\n    key: \"signInWithPopup\",\n    value: function () {\n      var _signInWithPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(provider) {\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              _assert$1(_isPopupRedirectSupported(), this._delegate, \"operation-not-supported-in-this-environment\" /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */);\n              return _context15.abrupt(\"return\", convertCredential(this._delegate, exp.signInWithPopup(this._delegate, provider, CompatPopupRedirectResolver)));\n            case 2:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function signInWithPopup(_x24) {\n        return _signInWithPopup.apply(this, arguments);\n      }\n      return signInWithPopup;\n    }()\n  }, {\n    key: \"signInWithRedirect\",\n    value: function () {\n      var _signInWithRedirect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(provider) {\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              _assert$1(_isPopupRedirectSupported(), this._delegate, \"operation-not-supported-in-this-environment\" /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */);\n              _context16.next = 3;\n              return _savePersistenceForRedirect(this._delegate);\n            case 3:\n              return _context16.abrupt(\"return\", exp.signInWithRedirect(this._delegate, provider, CompatPopupRedirectResolver));\n            case 4:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function signInWithRedirect(_x25) {\n        return _signInWithRedirect.apply(this, arguments);\n      }\n      return signInWithRedirect;\n    }()\n  }, {\n    key: \"updateCurrentUser\",\n    value: function updateCurrentUser(user) {\n      // remove ts-ignore once overloads are defined for exp functions to accept compat objects\n      // @ts-ignore\n      return this._delegate.updateCurrentUser(user);\n    }\n  }, {\n    key: \"verifyPasswordResetCode\",\n    value: function verifyPasswordResetCode(code) {\n      return exp.verifyPasswordResetCode(this._delegate, code);\n    }\n  }, {\n    key: \"unwrap\",\n    value: function unwrap() {\n      return this._delegate;\n    }\n  }, {\n    key: \"_delete\",\n    value: function _delete() {\n      return this._delegate._delete();\n    }\n  }, {\n    key: \"linkUnderlyingAuth\",\n    value: function linkUnderlyingAuth() {\n      var _this = this;\n      this._delegate.wrapped = function () {\n        return _this;\n      };\n    }\n  }, {\n    key: \"emulatorConfig\",\n    get: function get() {\n      return this._delegate.emulatorConfig;\n    }\n  }, {\n    key: \"currentUser\",\n    get: function get() {\n      if (!this._delegate.currentUser) {\n        return null;\n      }\n      return User.getOrCreate(this._delegate.currentUser);\n    }\n  }, {\n    key: \"languageCode\",\n    get: function get() {\n      return this._delegate.languageCode;\n    },\n    set: function set(languageCode) {\n      this._delegate.languageCode = languageCode;\n    }\n  }, {\n    key: \"settings\",\n    get: function get() {\n      return this._delegate.settings;\n    }\n  }, {\n    key: \"tenantId\",\n    get: function get() {\n      return this._delegate.tenantId;\n    },\n    set: function set(tid) {\n      this._delegate.tenantId = tid;\n    }\n  }]);\n  return Auth;\n}();\nAuth.Persistence = Persistence;\nfunction wrapObservers(nextOrObserver, error, complete) {\n  var next = nextOrObserver;\n  if (typeof nextOrObserver !== 'function') {\n    next = nextOrObserver.next;\n    error = nextOrObserver.error;\n    complete = nextOrObserver.complete;\n  }\n  // We know 'next' is now a function\n  var oldNext = next;\n  var newNext = function newNext(user) {\n    return oldNext(user && User.getOrCreate(user));\n  };\n  return {\n    next: newNext,\n    error: error,\n    complete: complete\n  };\n}\nfunction buildPersistenceHierarchy(apiKey, appName) {\n  // Note this is slightly different behavior: in this case, the stored\n  // persistence is checked *first* rather than last. This is because we want\n  // to prefer stored persistence type in the hierarchy. This is an empty\n  // array if window is not available or there is no pending redirect\n  var persistences = _getPersistencesFromRedirect(apiKey, appName);\n  // If \"self\" is available, add indexedDB\n  if (typeof self !== 'undefined' && !persistences.includes(exp.indexedDBLocalPersistence)) {\n    persistences.push(exp.indexedDBLocalPersistence);\n  }\n  // If \"window\" is available, add HTML Storage persistences\n  if (typeof window !== 'undefined') {\n    for (var _i = 0, _arr = [exp.browserLocalPersistence, exp.browserSessionPersistence]; _i < _arr.length; _i++) {\n      var persistence = _arr[_i];\n      if (!persistences.includes(persistence)) {\n        persistences.push(persistence);\n      }\n    }\n  }\n  // Add in-memory as a final fallback\n  if (!persistences.includes(exp.inMemoryPersistence)) {\n    persistences.push(exp.inMemoryPersistence);\n  }\n  return persistences;\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar PhoneAuthProvider = /*#__PURE__*/function () {\n  function PhoneAuthProvider() {\n    _classCallCheck(this, PhoneAuthProvider);\n    this.providerId = 'phone';\n    // TODO: remove ts-ignore when moving types from auth-types to auth-compat\n    // @ts-ignore\n    this._delegate = new exp.PhoneAuthProvider(unwrap(firebase.auth()));\n  }\n  _createClass(PhoneAuthProvider, [{\n    key: \"verifyPhoneNumber\",\n    value: function verifyPhoneNumber(phoneInfoOptions, applicationVerifier) {\n      return this._delegate.verifyPhoneNumber(\n      // The implementation matches but the types are subtly incompatible\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      phoneInfoOptions, applicationVerifier);\n    }\n  }, {\n    key: \"unwrap\",\n    value: function unwrap() {\n      return this._delegate;\n    }\n  }], [{\n    key: \"credential\",\n    value: function credential(verificationId, verificationCode) {\n      return exp.PhoneAuthProvider.credential(verificationId, verificationCode);\n    }\n  }]);\n  return PhoneAuthProvider;\n}();\nPhoneAuthProvider.PHONE_SIGN_IN_METHOD = exp.PhoneAuthProvider.PHONE_SIGN_IN_METHOD;\nPhoneAuthProvider.PROVIDER_ID = exp.PhoneAuthProvider.PROVIDER_ID;\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar _assert = exp._assert;\nvar RecaptchaVerifier = /*#__PURE__*/function () {\n  function RecaptchaVerifier(container, parameters) {\n    var app = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : firebase.app();\n    _classCallCheck(this, RecaptchaVerifier);\n    var _a;\n    // API key is required for web client RPC calls.\n    _assert((_a = app.options) === null || _a === void 0 ? void 0 : _a.apiKey, \"invalid-api-key\" /* exp.AuthErrorCode.INVALID_API_KEY */, {\n      appName: app.name\n    });\n    this._delegate = new exp.RecaptchaVerifier(container,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parameters,\n    // TODO: remove ts-ignore when moving types from auth-types to auth-compat\n    // @ts-ignore\n    app.auth());\n    this.type = this._delegate.type;\n  }\n  _createClass(RecaptchaVerifier, [{\n    key: \"clear\",\n    value: function clear() {\n      this._delegate.clear();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this._delegate.render();\n    }\n  }, {\n    key: \"verify\",\n    value: function verify() {\n      return this._delegate.verify();\n    }\n  }]);\n  return RecaptchaVerifier;\n}();\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar AUTH_TYPE = 'auth-compat';\n// Create auth components to register with firebase.\n// Provides Auth public APIs.\nfunction registerAuthCompat(instance) {\n  instance.INTERNAL.registerComponent(new Component(AUTH_TYPE, function (container) {\n    // getImmediate for FirebaseApp will always succeed\n    var app = container.getProvider('app-compat').getImmediate();\n    var authProvider = container.getProvider('auth');\n    return new Auth(app, authProvider);\n  }, \"PUBLIC\" /* ComponentType.PUBLIC */).setServiceProps({\n    ActionCodeInfo: {\n      Operation: {\n        EMAIL_SIGNIN: exp.ActionCodeOperation.EMAIL_SIGNIN,\n        PASSWORD_RESET: exp.ActionCodeOperation.PASSWORD_RESET,\n        RECOVER_EMAIL: exp.ActionCodeOperation.RECOVER_EMAIL,\n        REVERT_SECOND_FACTOR_ADDITION: exp.ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,\n        VERIFY_AND_CHANGE_EMAIL: exp.ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,\n        VERIFY_EMAIL: exp.ActionCodeOperation.VERIFY_EMAIL\n      }\n    },\n    EmailAuthProvider: exp.EmailAuthProvider,\n    FacebookAuthProvider: exp.FacebookAuthProvider,\n    GithubAuthProvider: exp.GithubAuthProvider,\n    GoogleAuthProvider: exp.GoogleAuthProvider,\n    OAuthProvider: exp.OAuthProvider,\n    SAMLAuthProvider: exp.SAMLAuthProvider,\n    PhoneAuthProvider: PhoneAuthProvider,\n    PhoneMultiFactorGenerator: exp.PhoneMultiFactorGenerator,\n    RecaptchaVerifier: RecaptchaVerifier,\n    TwitterAuthProvider: exp.TwitterAuthProvider,\n    Auth: Auth,\n    AuthCredential: exp.AuthCredential,\n    Error: FirebaseError\n  }).setInstantiationMode(\"LAZY\" /* InstantiationMode.LAZY */).setMultipleInstances(false));\n  instance.registerVersion(name, version);\n}\nregisterAuthCompat(firebase);","map":null,"metadata":{},"sourceType":"module"}